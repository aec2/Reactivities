You’re getting hammered by two N+1s per row (DB + SAP) and returning way too much to the UI. Here’s how to fix it decisively:

What’s wrong now

For each batch you:

Query grinding totals twice via Where(x => x.Batch.BatchNumber == batchNumber) → N trips to DB and an extra join to Batch.

Call SAP GetMaterial(batchDto.ToolNumber) for every row even though toolNumber is identical for all rows.


You map entities to DTOs before computing aggregates, forcing more queries.

You return 5000+ rows to Angular in one go → slow UI no matter what.


Fixes that move the needle (server-side)

1. Call SAP once per toolNumber and cache it.


2. Compute both sums in a single SQL query using a left-join + GroupBy (by BatchId, not string BatchNumber).


3. Use AsNoTracking() + Async to cut EF overhead.


4. Return paged results (PagedResultDto<T>) and load more on demand in Angular.


5. Indexing: Batches.ToolNumber, Grinding.BatchId (and consider a unique index on Batch.BatchNumber if you must filter by it).


6. (Optional) Denormalize: store TotalGrindingTimes/TotalScrapTimes on Batch and update on write.




---

Drop-in replacement (ABP + EF Core 3.1)

DTO input (paging)

public class GetBatchesInput : PagedAndSortedResultRequestDto
{
    public string ToolNumber { get; set; }
}

Service method (single SQL for sums + single SAP call)

public async Task<PagedResultDto<BatchDto>> GetAllByToolNumberAsync(GetBatchesInput input)
{
    // 1) Fetch SAP once and cache (see cache snippet below)
    var material = await _sapService.GetMaterialAsync(input.ToolNumber);
    decimal grindingLife = 0m;
    if (!string.IsNullOrWhiteSpace(material?.GrindingLife))
        decimal.TryParse(material.GrindingLife, NumberStyles.Any, CultureInfo.InvariantCulture, out grindingLife);

    // 2) Base query (no tracking, filter early)
    var baseQuery = _batchRepository.GetAll()
        .AsNoTracking()
        .Where(b => b.ToolNumber == input.ToolNumber);

    var totalCount = await baseQuery.CountAsync();

    // 3) Apply sorting/paging (ABP supports Dynamic LINQ)
    var pagedBatches = baseQuery
        .OrderBy(string.IsNullOrWhiteSpace(input.Sorting) ? "Id DESC" : input.Sorting)
        .Skip(input.SkipCount)
        .Take(input.MaxResultCount);

    // 4) Compute aggregates in ONE DB roundtrip by joining Grinding on BatchId
    var query =
        from b in pagedBatches
        join g in _grindingRepository.GetAll().AsNoTracking() on b.Id equals g.BatchId into ggrp
        select new
        {
            Batch = b,
            ScrapTimes = ggrp.Sum(x => (decimal?)x.ScrapAmount) ?? 0m,
            GrindingTimes = ggrp.Sum(x => (decimal?)x.GrindingTimes) ?? 0m
        };

    var rows = await query.ToListAsync();

    // 5) Project to DTOs only once (and set GrindingLife once)
    var dtos = rows.Select(r => new BatchDto
    {
        // map entity properties you need:
        Id = r.Batch.Id,
        BatchNumber = r.Batch.BatchNumber,
        ToolNumber = r.Batch.ToolNumber,
        // ...
        ScrapTimes = r.ScrapTimes,
        GrindingTimes = r.GrindingTimes,
        GrindingLife = grindingLife
    }).ToList();

    return new PagedResultDto<BatchDto>(totalCount, dtos);
}

SAP call: make it async + cache

// Example using ABP IDistributedCache; cache for 10 minutes (tune to your needs)
private readonly IDistributedCache<MaterialCacheItem> _materialCache;

public async Task<Material> GetMaterialAsync(string materialNumber, CancellationToken ct = default)
{
    var cacheKey = $"material:{materialNumber}";
    var cached = await _materialCache.GetAsync(cacheKey, ct);
    if (cached != null) return cached.Material;

    // your REST call should use async APIs
    var material = await _baseSapService.ExecuteRequestAsync<Material>($"Materials/{materialNumber}", Method.Get, ct);

    await _materialCache.SetAsync(cacheKey, new MaterialCacheItem { Material = material },
        new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)
        }, ct);

    return material;
}

[Serializable]
public class MaterialCacheItem
{
    public Material Material { get; set; }
}

> If you can’t switch your _baseSapService to async right now, at least ensure you call it once per request and cache it; do not call it inside the row loop.




---

If you must keep your existing method shape (no paging)

At least eliminate the N+1s and join aggregates once:

public async Task<List<BatchDto>> GetAllByToolNumberAsync(string toolNumber)
{
    var material = await _sapService.GetMaterialAsync(toolNumber);
    decimal grindingLife = 0m;
    if (!string.IsNullOrWhiteSpace(material?.GrindingLife))
        decimal.TryParse(material.GrindingLife, NumberStyles.Any, CultureInfo.InvariantCulture, out grindingLife);

    var query =
        from b in _batchRepository.GetAll().AsNoTracking()
        where b.ToolNumber == toolNumber
        join g in _grindingRepository.GetAll().AsNoTracking() on b.Id equals g.BatchId into ggrp
        select new BatchDto
        {
            Id = b.Id,
            BatchNumber = b.BatchNumber,
            ToolNumber = b.ToolNumber,
            ScrapTimes = ggrp.Sum(x => (decimal?)x.ScrapAmount) ?? 0m,
            GrindingTimes = ggrp.Sum(x => (decimal?)x.GrindingTimes) ?? 0m,
            GrindingLife = grindingLife
        };

    return await query.ToListAsync();
}


---

Angular/UI side (quick wins)

Switch the table to server-side paging (ABP + Angular → call the paged method above).

Add filtering & sorting on the server.

Use virtual scroll for large lists (if you still browse thousands).

Consider making GrindingLife a column that loads on expand/hover if SAP is slow—one more endpoint that returns only the needed field for a given toolNumber.



---

DB & EF tips

Prefer BatchId over BatchNumber in joins/filters; if you must filter by BatchNumber, index it.

Keep queries translatable by EF Core 3.1 (avoid client-eval; the GroupBy/joins shown above are safe).

Use AsNoTracking() for read-only lists.



---

TL;DR

One SAP call, one SQL for both sums, paged results.

This alone removes thousands of roundtrips and will make the page snappy.


If you paste your entity shapes (Batch, Grinding) and current Angular table, I can tailor the LINQ and the client call exactly to your codebase (including sorting fields & filters).

